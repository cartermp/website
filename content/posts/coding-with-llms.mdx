---
title: How I code with LLMs
description: Practical tips for developers looking to use AI coding assistants
date: "2025-01-31"
tags: ai, development
---

I first started using AI coding assistants in early 2021, with an invite code from a friend who worked on the original GitHub Copilot team. Back then the workflow was just single-line tab completion, but you could also guide code generation with comments and it'd try its best to implement what you want.

Fast forward now to 2025, and there's a wide range of coding assistants that are packed with features, the models have gotten substantially more powerful, and the way I develop with them has changed too. They're an essential part of coding for me in various contexts.

However, many developers remain skeptical of the of AI coding assistants. This is usually because they tried a vague task with a free AI model in the past and noticed incorrect code, hallucinated API calls, or some other issue. Others have incorporated these tools, as have their teams, but use of these tools hasn't resulted in more working software. In some cases, the tools have lowered overall productivity because teams had to hunt down bugs where the root cause involved a developer who blindly trusted AI-generated code.

I've chosen to write this post specifically for those who are skeptical or have came away unimpressed. I can't promise that if you follow what I say that you'll fall in love with AI coding assistants. But I do believe that if you adopt some of the following tips, you'll come away substantially more impressed than you might be today.

## But first, skill issue

AI-assistants are tools, not magic, and to use them effectively, you need to develop skills to be effective. If there's one single thing to take away from my post, it's that AI is a tool that requires developing skills to weild effectively. If you do not invest in these skills, you will be ineffective using AI for coding.

## Use Claude and pay for it

Before you stress about getting skilled at using AI coding tools, first you need to actually get a good tool.

Right now, the best AI model for coding is [Claude](https://claude.ai/new). There are [coding benchmarks](https://www.anthropic.com/research/swe-bench-sonnet) that Claude scores well for, but you'll find in the AI community that everyone claims that these benchmarks don't come close to doing it justice. Somehow, in some way, Claude has this _je ne sais quoi_ where it doesn't veer off course much as you use it, the code it writes for your codebase seems to fit the style of your code, and it just doesn't make up API calls that don't exist.

You can suffice with ChatGPT or Gemini or other models, but you'll need to be on your guard more because these tend to "drift" from the style and goals you set in the code that they suggest over time.

Do not take this recommendation lightly. Claude is the only model that you can reliably _not_ have to second-guess every time you use it. I have found that it can still make mistakes, but more often than not, these mistakes have come becuase I didn't provide enough (or accurate) context, such as forgetting to mention that I updated some other part of the codebase. And as I'll discuss later on, you can eliminate most of these problems as well with particular prompting techniques.

**If you formed your opinion about AI coding assistants from using free ChatGPT a year ago, you need to radically update your priors**. The gap between free AI tools and premium models like Claude has widened substantially, and the capabilities have advanced dramatically.

Maybe at some point, another model will de-throne Claude for coding. Claude is also not necessarily the best for non-coding workflows. But for now, it's the one to use.

### Use Claude in whatever tool you like

Since Claude is not just the chatbot, but a model, it can be used to power any number of coding assistants -- Copilot, Cursor, WindSurf, and more. I personally don't use these tools much and usually just copy/paste from the Claude web interface, but little that I'll describe in this post prohibits the use of other tools.

## Domain Knowledge is Your Multiplier 

The effectiveness of AI coding assistants varies significantly based on the type of development work you're doing. I've found three key factors that predict success:

1. Task commonality: The more common your development task, the more likely the AI will excel at it. This makes intuitive sense—models have been trained on vast amounts of public code, and common patterns are well-represented in that training data.

2. "Online" development: Web development, in particular, benefits enormously from AI assistance. This is partly due to the vast amount of web development code available for training, but also because web technologies often have immediate visual feedback loops.

3. Rapid feedback cycles: The easier it is to run and verify code, the more effective AI assistance becomes. This is why tasks with quick feedback loops (like frontend development or unit test writing) tend to work particularly well.

## Rethinking the Build vs. Integrate Decision

One unexpected lesson from working with AI coding assistants is that they've completely changed the calculus of when to use external libraries. Here's a controversial take: many of the libraries we traditionally use to "save time" are actually creating more complexity than they're worth in an AI-assisted workflow.

Consider the typical scenario: you need some boilerplate code, so you reach for a library that handles it for you. But now you need to:

1. Learn the library's API
2. Handle its dependencies
3. Deal with version conflicts
4. Navigate breaking changes
5. Work around its limitations

In an AI-assisted workflow, generating that boilerplate code directly is often faster and results in more maintainable code. The AI can generate exactly what you need, and you maintain full control over the implementation.

This isn't universally true—libraries that solve genuinely hard problems are still invaluable. But it's worth re-examining your assumptions about what constitutes a "hard problem" versus just "tedious work."

## The New Development Loop

The most profound change I've observed is in the fundamental development loop itself. Traditional development often follows a linear path: write code, run it, debug, repeat. With AI assistance, the loop becomes more dynamic and iterative:

1. Build context first: Spend time upfront creating a "context package"—code samples, screenshots, architectural diagrams, and clear constraints. This investment pays off in more accurate and relevant code generation.

2. Focus on specificity: Vague instructions lead to vague results. Be explicit about your requirements, constraints, and success criteria. The AI can handle complexity, but it needs clear direction.

3. Embrace rapid iteration: Code generation is cheap. Instead of trying to get everything perfect in one go, iterate quickly. Show the AI error messages, ask for adjustments, and refine the implementation incrementally.

4. Verify intentionally: Define how you'll verify the code works before you generate it. This forces clarity about requirements and helps avoid the "looks good, ship it" trap.

One particularly effective pattern I've developed is asking the AI to "think about this a bit" for complex tasks. This prompt often leads to more thoughtful and robust solutions, as it encourages the model to consider edge cases and potential issues before generating code.

## Start Small, Think Big

The most common mistake I see developers make is trying to generate too much code at once. While modern AI models are capable of generating substantial amounts of code, the complexity of specifying behavior and constraints grows exponentially with the size of the generated codebase.

Instead, start with small, well-defined components or features. As you become more comfortable with the AI-assisted workflow, you'll naturally develop patterns for handling larger pieces of functionality. This approach also helps you build intuition about what kinds of tasks are well-suited to AI assistance and which are better handled traditionally.

Remember: the goal isn't to replace traditional development practices but to augment them with AI capabilities where they make sense. Sometimes that means generating an entire component; other times, it means using the AI as a sounding board for design decisions or documentation writing.

The future of development isn't about AI replacing developers—it's about developers who know how to effectively use AI tools outperforming those who don't. The sooner you start building that capability, the better positioned you'll be for what's coming next.